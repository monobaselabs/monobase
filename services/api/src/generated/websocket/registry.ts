/**
 * WebSocket handler registry - Auto-generated
 * DO NOT EDIT - Generated by scripts/generate.ts
 */

import type { Context } from 'hono';
import type { App } from '@/types/app';
import { config as user_config } from '@/handlers/ws/ws.user';
import { config as chatRoom_config } from '@/handlers/comms/ws.chat-room';

export const wsRegistry = {
  'user_config': user_config,
  'chatRoom_config': chatRoom_config,
};

export function registerRoutes(app: App) {
  const ws = app.ws;

  for (const [name, config] of Object.entries(wsRegistry)) {
    const handlers = config.middleware || [];

    app.get(config.path, ...handlers, ws.upgradeWebSocket((ctx: Context) => ({
      async onOpen(event: MessageEvent, wsCtx: any) {
        const logger = ctx.get('logger');
        try {
          // Assign unique ID to raw WebSocket for reliable identity tracking across lifecycle methods
          // (Hono creates new WSContext wrappers for each lifecycle method, so we store on .raw which persists)
          const uniqueId = Math.random().toString(36).substring(7) + Date.now();
          (wsCtx.raw as any).__wsId = uniqueId;

          // Call handler's onConnect
          if (config.onConnect) {
            await config.onConnect(ctx, wsCtx);
          }
        } catch (error) {
          logger.error({
            error,
            handler: name,
            path: config.path,
            lifecycle: 'onConnect'
          }, 'WebSocket connection error');
          wsCtx.close(1011, 'Internal server error');
        }
      },

      async onMessage(event: MessageEvent, wsCtx: any) {
        const logger = ctx.get('logger');
        if (!config.onMessage) return;

        try {
          const message = JSON.parse(event.data.toString());
          await config.onMessage(ctx, wsCtx, message);
        } catch (error) {
          if (error instanceof SyntaxError) {
            logger.error({
              error,
              handler: name,
              path: config.path,
              rawData: event.data.toString()
            }, 'Failed to parse WebSocket message');
          } else {
            logger.error({
              error,
              handler: name,
              path: config.path,
              lifecycle: 'onMessage'
            }, 'WebSocket message processing error');
          }
        }
      },

      async onClose(event: CloseEvent, wsCtx: any) {
        const logger = ctx.get('logger');
        try {
          // Call handler's onClose
          if (config.onClose) {
            await config.onClose(ctx, wsCtx);
          }
        } catch (error) {
          logger.error({
            error,
            handler: name,
            path: config.path,
            lifecycle: 'onClose'
          }, 'WebSocket close error');
        }
      },

      async onError(event: Event, wsCtx: any) {
        const logger = ctx.get('logger');

        try {
          if (config.onError) {
            await config.onError(ctx, wsCtx, event);
          } else {
            // Default error handler - logs error with handler context
            logger.error({
              error: event,
              handler: name,
              path: config.path
            }, 'WebSocket error');
          }
        } catch (error) {
          logger.error({
            error,
            handler: name,
            path: config.path,
            lifecycle: 'onError'
          }, 'Error in WebSocket error handler');
        }
      },
    })));

    app.logger.debug(`Registered WebSocket route: ${config.path}`);
  }
}
